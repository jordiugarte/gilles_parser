import java_cup.runtime.*;        // Necessary
import java.io.InputStreamReader; // To read Input from command-line

parser code {:
    private static String BREAK = "\n";

    private static Parser instance;
    
    private static StringBuilder finalResult = new StringBuilder();
    private static List<String> variables = new ArrayList<String>();

    public static void main(String[] args)throws Exception{
        // Simplest interactive shell
        instance = new Parser(new Lexer(new InputStreamReader(System.in)));
        instance.parse();
        System.out.println(llvmCode.toString());
    }

    private String header(String progName) {
        finalResult.append("; ModuleID = " + progName + BREAK)
                    .append("declare i32 @printf(i8*, ...)" + BREAK)
                    .append("@.str = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\"" + BREAK + BREAK);
        return null;
    }

    private static String column() {
        finalResult.append(BREAK);
        return null;
    }

    private static String footer() {
        finalResult.append("ret i32 0\n");
        return null;
    }

    private static String assign(String varName, String value) {
        if (variables.contains(varName)) {
            //RETURN ERROR
        } else {
            String var = "%" + varName;
            finalResult.append(var + " = store i32, align 4" + BREAK);
            finalResult.append("store i32 " + value + ", i32* " + var + BREAK);
        }
        return null;
    }
:}

/* Terminals (tokens returned by the scanner). */
terminal          LET, BE, END, IF, THEN, ELSE, WHILE, REPEAT;
terminal          OUT, IN, COLUMN, ASSIGN, PLUS, MINUS, TIMES, DIVIDE;
terminal          LPAREN, RPAREN, LBRACK, RBRACK, EQUAL;
terminal          SMALLEQ, SMALLER, IMPLIES, PIPE;
terminal String   ProgName, VarName;
terminal Integer  Number;

/* Non-terminals */
non terminal            Program, Code, Instruction, Assign, While, Output, Input;
non terminal            ExprArith, ExprArithPrime, Prod, ProdPrime, Atom, If, IfTail;
non terminal            Cond, CondPrime, SimpleCond, Comp;

/* The grammar */
Program           ::= LET ProgName:pn BE Code:cd END
                    {: 
                        header();
                        $cd;
                        footer();
                    :};
Code              ::= Instruction:in COLUMN:col Code:cd 
                    {:
                        $in;
                        column();
                        $cd;
                    :}
                    | /* epsilon */ {: :}
                    ;
Instruction       ::= Assign
                    | If
                    | While
                    | Output
                    | Input
                    ;
Assign            ::= VarName:vn ASSIGN ExprArith:ea
                    {:
                        assign($vn, $ea);
                    :}
                    ;
ExprArith         ::= Prod ExprArithPrime
                    {:
                        
                    :}
                    ;
ExprArithPrime    ::= PLUS Prod ExprArithPrime
                    | MINUS Prod ExprArithPrime
                    | /* epsilon */
                    ;
Prod              ::= Atom ProdPrime
                    ;
ProdPrime         ::= TIMES Atom ProdPrime
                    | DIVIDE Atom ProdPrime
                    | /* epsilon */
                    ;
Atom              ::= VarName
                    | Number
                    | LPAREN ExprArith RPAREN
                    | MINUS Atom
                    ;
If                ::= IF LBRACK Cond RBRACK THEN Code IfTail
                    ;
IfTail            ::= END
                    | ELSE Code END
                    ;
Cond              ::= SimpleCond CondPrime
                    ;
CondPrime         ::= IMPLIES Cond
                    | /* epsilon */
                    ;
SimpleCond        ::= PIPE Cond PIPE
                    | ExprArith Comp ExprArith
                    ;
Comp              ::= EQUAL
                    | SMALLEQ
                    | SMALLER
                    ;
While             ::= WHILE LBRACK Cond RBRACK REPEAT Code END
                    ;
Output            ::= OUT LPAREN VarName RPAREN
                    ;
Input             ::= IN LPAREN VarName RPAREN
                    ;