\setcounter{secnumdepth}{3}

 % Main Body Chapters
	\section{Part 1}
	\subsection{Lexical Analyzer}
	The lexical analyzer is responsible for scanning the source code, identifying lexical units,
	and managing a symbol table essential for further compilation stages.
	The lexical analyzer is implemented using JFlex, a lexical analyzer generator for Java.
	The JFlex file \texttt{LexicalAnalyzer.flex} contains the regular expressions that define the lexical units of the GILLES language.
	The JFlex tool is used to generate the Java source code for the lexical analyzer.
	The generated Java source code is then compiled and executed to analyze the source code of GILLES programs.
	The lexical analyzer reads the source code character by character, identifies the lexical units, and stores them in the symbol table.
	The symbol table is a data structure that stores information about the lexical units, such as their type, value, and position in the source code.
	The lexical analyzer also handles errors in the source code, such as invalid characters or tokens, and reports them to the user, if an unrecognised symbol is recognised we throw an \("\)Unknown symbol detected\("\) error.
	The lexical analyzer is of course the first essential component of the compiler, as it provides the input for the parser, which analyzes the syntactic structure of the source code.\\

	\subsection{Regular Expressions used}
	Following the grammar rules, the following regular expressions were used to define the lexical units of the GILLES language:
	\begin{align*}
		&\text{ProgName}     = [a-zA-Z\_][a-zA-Z0-9\_]* \\
		&\text{VarName}      = [a-zA-Z\_][a-zA-Z0-9\_]* \\
		&\text{Number}       = [0-9]+ \\
		&\text{Whitespace}   = [ \text{\textbackslash} t\text{\textbackslash} r\text{\textbackslash} n]+ \\
		&\text{Comment}      = "!!"[^\text{\textbackslash} n]* \\
		&\text{ShortComment} = "\$"[^\text{\textbackslash} n]*
	\end{align*}
    \begin{table}[h]
		\centering
		\caption{Regular expressions used}
	\end{table}

	These are relatively straightforward RegExps that identify the different types of tokens in the GILLES language. We will see how they're used in the JFlex file in the next section.\\

	\subsection{Lexer Rules}
	This section describes the main rules of the analyzer and how we transition from one block to another.\\

	Here we can see the main rules of the lexical analyzer:

	\subsubsection{The initial \texttt{LET} Statement}
	The lexer begins in the \texttt{YYINITIAL} state, which captures the declaration of a program using the \texttt{LET} keyword. Upon encountering \texttt{LET}, the lexer transitions to the \texttt{PROGRAM} state, where the program name is expected, as per the grammar rule:

    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	<Program> → LET [ProgName] BE <Code> END
	\end{minted}
    \begin{table}[h]
		\centering
		\caption{Initialization of YYINITIAL state}
	\end{table}

	In the lexer, this is represented as:

    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	"LET" { yybegin(PROGRAM);
			System.out.println(new Symbol(LexicalUnit.LET, yyline, yycolumn, yytext())); }
	\end{minted}
    \begin{table}[h]
		\centering
		\caption{Initialization of YYINITIAL state in the lexer}
	\end{table}

	Once \texttt{LET} is matched, the lexer moves to the \texttt{PROGRAM} state where it expects the program name (\texttt{[ProgName]}), ensuring adherence to the grammar rule that requires a program name after \texttt{LET}.

	\subsubsection{ProgName and transition to the CODE block}
	After matching the program name in the \texttt{PROGRAM} state, the lexer transitions to the \texttt{CODE} state upon encountering the \texttt{BE} keyword, as required by the grammar:

    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
		<Code> → <Instruction> : <Code>
		<Instruction> → <Assign>
					→ <If>
					→ <While>
					→ <Call>
					→ <Output>
					→ <Input>
	\end{minted}
    \begin{table}[h]
		\centering
		\caption{ProgName and transition to the CODE block}
	\end{table}

    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	{ProgName} { yybegin(CODE);
				 System.out.println(new Symbol(LexicalUnit.PROGNAME, yyline, yycolumn, yytext())); }
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{ProgName and transition to the CODE block}
	\end{table}

	The instruction block has been broken down into the different types of blocks directly rather than one by one for simplicity.\\

	\subsubsection{Code Block}

	The following is the implementation of the \texttt{CODE} block in the lexer:

    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	/* Code block state */
	<CODE> {
	  {Whitespace}+          { /* Ignore whitespace */ }
	  {Comment}              { /* Ignore comments */ }
	  {ShortComment}         { /* Ignore short comments */ }
	  "BE"                   { System.out.println(
									new Symbol(LexicalUnit.BE, yyline, yycolumn, yytext())); }
	  "END"                  {
								yybegin(CODE);
								System.out.println(
									new Symbol(LexicalUnit.END, yyline, yycolumn, yytext()));
						     }
	  ":"                    { System.out.println(
									new Symbol(LexicalUnit.COLUMN, yyline, yycolumn, yytext())); }
	  {VarName}"="           { yybegin(ARITHMETIC); System.out.println(
									new Symbol(LexicalUnit.ASSIGN, yyline, yycolumn, yytext())); }
	  "="                    { yybegin(ARITHMETIC); System.out.println(
									new Symbol(LexicalUnit.ASSIGN, yyline, yycolumn, yytext())); }
	  "IN"                   { yybegin(INPUT_OUTPUT); System.out.println(
									new Symbol(LexicalUnit.INPUT, yyline, yycolumn, yytext())); }
	  "OUT"                  { yybegin(INPUT_OUTPUT); System.out.println(
									new Symbol(LexicalUnit.OUTPUT, yyline, yycolumn, yytext())); }
	  "IF"                   { yybegin(CONDITION); System.out.println(
									new Symbol(LexicalUnit.IF, yyline, yycolumn, yytext())); }
	  "WHILE"                { yybegin(CONDITION); System.out.println(
									new Symbol(LexicalUnit.WHILE, yyline, yycolumn, yytext())); }
	  "ELSE"                 { System.out.println(
									new Symbol(LexicalUnit.ELSE, yyline, yycolumn, yytext())); }
	  {VarName}              {
								if (!variables.containsKey(yytext())) {
									variables.put(yytext(), yyline+1);
								}
								System.out.println(
									new Symbol(LexicalUnit.VARNAME, yyline, yycolumn, yytext()));
							 }
	  "("                    { System.out.println(
									new Symbol(LexicalUnit.LPAREN, yyline, yycolumn, yytext())); }
	  ")"                    { System.out.println(
									new Symbol(LexicalUnit.RPAREN, yyline, yycolumn, yytext())); }
	}
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Implementation of Code Block in the lexer}
	\end{table}

	Since there is a recursive definition of the \texttt{Code} block, the lexer transitions back to the \texttt{CODE} state after processing each instruction. This allows the lexer to handle multiple instructions in a program, as defined by the grammar.\\

	We have also left out the \texttt{Call} block as it is not used in the grammar.\\

	The "ELSE" keyword is also handled in the CODE block since it is not a separate block in the grammar. Once this has been parsed, the lexer should stay in the CODE block.\\


	\subsubsection{Condition Block}
	The lexer transitions to the \texttt{CONDITION} state upon encountering the \texttt{IF} or \texttt{WHILE} keywords, as defined in the grammar:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	<If> → IF { <Cond> } THEN <Code> END
		 → IF { <Cond> } THEN <Code> ELSE <Code> END
	<While> → WHILE {<Cond>} REPEAT <Code> END
	\end{minted}

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	/* Conditionals and loops */
	<CONDITION> {
	  "THEN"                 { yybegin(CODE); System.out.println(
								new Symbol(LexicalUnit.THEN, yyline, yycolumn, yytext())); }
	  "ELSE"                 { yybegin(CODE); System.out.println(
								new Symbol(LexicalUnit.ELSE, yyline, yycolumn, yytext())); }
	  "REPEAT"               { yybegin(CODE); System.out.println(
								new Symbol(LexicalUnit.REPEAT, yyline, yycolumn, yytext())); }
	  "END"                  { yybegin(CODE); System.out.println(
								new Symbol(LexicalUnit.END, yyline, yycolumn, yytext())); }
	  {Whitespace}           { /* Ignore whitespace */ }
	  {Number}               { System.out.println(
								new Symbol(LexicalUnit.NUMBER, yyline, yycolumn, yytext())); }
	  {VarName}              {
								if (!variables.containsKey(yytext())) {
									variables.put(yytext(), yyline+1);
								}
								System.out.println(
									new Symbol(LexicalUnit.VARNAME, yyline, yycolumn, yytext()));
							 }
	  "=="                   { System.out.println(
								new Symbol(LexicalUnit.EQUAL, yyline, yycolumn, yytext())); }
	  "<="                   { System.out.println(
								new Symbol(LexicalUnit.SMALEQ, yyline, yycolumn, yytext())); }
	  "<"                    { System.out.println(
								new Symbol(LexicalUnit.SMALLER, yyline, yycolumn, yytext())); }
	  "|"                    { System.out.println(
								new Symbol(LexicalUnit.PIPE, yyline, yycolumn, yytext())); }
	  "->"                   { System.out.println(
								new Symbol(LexicalUnit.IMPLIES, yyline, yycolumn, yytext())); }
	  "("                    { System.out.println(
								new Symbol(LexicalUnit.LPAREN, yyline, yycolumn, yytext())); }
	  ")"                    { System.out.println(
								new Symbol(LexicalUnit.RPAREN, yyline, yycolumn, yytext())); }
	  ":"                    { System.out.println(
								new Symbol(LexicalUnit.COLUMN, yyline, yycolumn, yytext())); }
	  "{"                    { System.out.println(
								new Symbol(LexicalUnit.LBRACK, yyline, yycolumn, yytext())); }
	  "}"                    { System.out.println(
								new Symbol(LexicalUnit.RBRACK, yyline, yycolumn, yytext())); }
	}
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Condition block implementation}
	\end{table}
 
	Notice also here that we do not have \">\" (GREATER\_THAN) as a token, this is because it is not used in the grammar (possibly left out intentionally?).\\

	\subsubsection{Assignment Statements}
	The assignment of values to variables is handled by recognizing both \texttt{VarName = ExprArith} as defined in the grammar:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
<Assign> → [VarName] = <ExprArith>
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Assignment of variables}
	\end{table}

	This rule is implemented in the lexer as:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
{VarName}"=" { yybegin(ARITHMETIC);
               System.out.println(new Symbol(LexicalUnit.ASSIGN, yyline, yycolumn, yytext())); }
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Implementation of assignment of variables}
	\end{table}

	Upon matching an assignment, the lexer transitions to the \texttt{ARITHMETIC} state to evaluate arithmetic expressions.

	\subsubsection{Arithmetic Expressions}
	Arithmetic expressions (\texttt{ExprArith}) are handled in the \texttt{ARITHMETIC} state. The lexer recognizes variable names, numbers, and operators (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}), as well as parentheses for grouping, as defined by the grammar:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
<ExprArith> → [VarName]
			→ [Number]
			→ ( <ExprArith> )
			→ - <ExprArith>
			→ <ExprArith> <Op> <ExprArith>
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Arithmetic expressions}
	\end{table}

	In the lexer, this is implemented as follows:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	/* Arithmetic expressions */
	<ARITHMETIC> {
	  {Whitespace}           { /* Ignore whitespace */ }
	  {Number}               { System.out.println(
									new Symbol(LexicalUnit.NUMBER, yyline, yycolumn, yytext())); }
	  {VarName}              {
								if (!variables.containsKey(yytext())) {
									variables.put(yytext(), yyline+1);
								}
								System.out.println(new Symbol(LexicalUnit.VARNAME, yyline, yycolumn, yytext()));
							 }
	  "+"                  { System.out.println(
									new Symbol(LexicalUnit.PLUS, yyline, yycolumn, yytext())); }
	  "-"                    { System.out.println(
									new Symbol(LexicalUnit.MINUS, yyline, yycolumn, yytext())); }
	  "*"                  { System.out.println(
									new Symbol(LexicalUnit.TIMES, yyline, yycolumn, yytext())); }
	  "/"                    { System.out.println(
									new Symbol(LexicalUnit.DIVIDE, yyline, yycolumn, yytext())); }
	  "("                    { System.out.println(
									new Symbol(LexicalUnit.LPAREN, yyline, yycolumn, yytext())); }
	  ")"                    { yybegin(CODE); System.out.println(
									new Symbol(LexicalUnit.RPAREN, yyline, yycolumn, yytext())); }
	  ":"                    { yybegin(CODE); System.out.println(
									new Symbol(LexicalUnit.COLUMN, yyline, yycolumn, yytext())); }
	}

	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Implementation of arithmetic expressions}
	\end{table}

	The arithmetic expressions are evaluated based on the sequence of operators and operands, this might be useful later when we need to evaluate the expressions.\\

	\subsubsection{Input and Output}
	Input and output operations are defined in the grammar as follows.
	The ) is used to move back to the CODE block since this rule has been collapsed into the CODE block instead of having it's own "Output" block.\\
	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
		/* Input/Output instructions */
	<INPUT_OUTPUT> {
	  {Whitespace}           { /* Ignore whitespace */ }
	  "("                    { System.out.println(new Symbol(LexicalUnit.LPAREN, yyline, yycolumn, yytext())); }
	  ")"                    { yybegin(CODE); System.out.println(new Symbol(LexicalUnit.RPAREN, yyline, yycolumn, yytext())); }
	  {VarName}              {
								if (!variables.containsKey(yytext())) {
									variables.put(yytext(), yyline+1);
								}
								System.out.println(new Symbol(LexicalUnit.VARNAME, yyline, yycolumn, yytext()));
							 }
	  ":"                    { System.out.println(new Symbol(LexicalUnit.COLUMN, yyline, yycolumn, yytext())); }
	}
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Input and output operations}
	\end{table}

	\subsubsection{Conditionals and Loops}
	Conditionals and loops are defined in the grammar as follows:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
<If> → IF { <Cond> } THEN <Code> END
<While> → WHILE {<Cond>} REPEAT <Code> END
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Conditionals and loops}
	\end{table}

	In the lexer, the \texttt{IF} and \texttt{WHILE} keywords trigger a transition to the \texttt{CONDITION} state where the conditional expressions are evaluated:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
"IF"    { yybegin(CONDITION);
          System.out.println(new Symbol(LexicalUnit.IF, yyline, yycolumn, yytext())); }
"WHILE" { yybegin(CONDITION);
          System.out.println(new Symbol(LexicalUnit.WHILE, yyline, yycolumn, yytext())); }
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Conditionals and loops implementation}
	\end{table}

	The \texttt{CONDITION} state then handles comparison operators (\texttt{==}, \texttt{<=}, \texttt{<}) and conditional expressions (\texttt{VarName}, \texttt{Number}, \texttt{ExprArith}), adhering to the grammar's definitions for conditions.

	\subsubsection{Input and Output}
	Input and output operations are defined as:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
<Output> → OUT([VarName])
<Input> → IN([VarName])
	\end{minted}

     \begin{table}[h]
		\centering
		\caption{Input and output operations}
	\end{table}

	In the lexer, these are handled in the \texttt{INPUT\_OUTPUT} state:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
"IN"  { yybegin(INPUT_OUTPUT);
        System.out.println(new Symbol(LexicalUnit.INPUT, yyline, yycolumn, yytext())); }
"OUT" { yybegin(INPUT_OUTPUT);
        System.out.println(new Symbol(LexicalUnit.OUTPUT, yyline, yycolumn, yytext())); }
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Input and output operations implementation}
	\end{table}

	This implementation captures the \texttt{IN} and \texttt{OUT} keywords, ensuring that the correct symbols are generated in accordance with the grammar.


	\subsubsection{Whitespace and Comments}
	The lexer is designed to ignore unnecessary whitespace and comments. Both multi-line (\texttt{\{Comment\}}) and single-line (\texttt{\{ShortComment\}}) comments are handled across different states to prevent irrelevant tokens from being processed. This aligns with the GILLES grammar, which does not consider whitespace and comments as significant parts of the language.

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	/* Ignore whitespace and comments */
	{Whitespace}           { /* Ignore whitespace */ }
	{Comment}              { /* Ignore comments */ }
	{ShortComment}         { /* Ignore short comments */ }
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Whitespaces and comments}
	\end{table}

	This ensures that the parsing of valid tokens, such as program names or arithmetic expressions, is unaffected by whitespace or comments.\\
	The reason that nested comments are not supported is that it is explicitly not part of the grammar, but also becasue nested comments are challenging to track, i.e., it
	is difficult to accurately track when a comment ends.\\

	For example, if your comment structure looks like !! to start and !! to end, the difficulty arises when we encounter something like this:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
	!! This is a 1st level comment
	   !! Nested 2nd level comment !!
	   1st level comment again !! $ Not a valid comment since it already ended above!
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Whitespaces and comments example}
	\end{table}

	In the above example, the lexer would need to keep track of the nested comments and ensure that it doesn't stop at the first !! it encounters. The solution would possibly be to
	introduce a stack to keep track of the nested comments but that seems like an overkill for the current simplistic grammar.\\

	\subsection{Symbol Table Management}

	The symbol table is implemented as a HashMap in Java, where each variable name (VarName) is mapped to its corresponding line number in the source code where it first appears.
	When a variable is encountered in the source code, the lexer checks if it is already present in the symbol table. If not, the variable name and its line number are added to the symbol table.

	\subsection{Error Handling}

	The lexer is designed to detect and report errors gracefully. When an unrecognized symbol is encountered or a symbol is encountered in the incorrect rule, the lexer throws an error with the message "Unknown symbol detected".

	For example, if the lexer encounters the > symbol, which is not defined in the current grammar, it will output:

	\begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
		Exception in thread "main" java.lang.Error: Unknown symbol detected 6, column 12: '>'
			at LexicalAnalyzer.yylex(LexicalAnalyzer.java:765)
			at Main.main(Main.java:11)
		make: *** [Makefile:45: test] Error 1
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Exception in case of error in the lexer}
	\end{table}

	\section{Testing}
	To test the lexical analyzer, we have provided a set of test files in the \texttt{test} folder. These test files contain GILLES programs that cover various aspects of the language.
	We've tried to incorporate different kinds of edge cases and code structures to ensure that the lexical analyzer can handle a wide range of inputs.
	\subsection{Test Files}
	\begin{itemize}
		\item \texttt{Euclid.gls} - A simple program to calculate the greatest common divisor of two numbers.
		\item \texttt{InvalidSymbolEuclid.gls} - Same as above but with an invalid symbol, .
		\item \texttt{Sum.gls} - A simple program to calculate the sum of two numbers.
		\item \texttt{ThreeLoopGibberish.gls} - An unncessarily complex program to test the lexer.
		\item \texttt{InvalidAssignment.gls} - A program with invalid syntax to test error handling.
		\item \texttt{ComplexAssignment.gls} - A program with complex arithmetic expression.
		\item \texttt{Fibonacci.gls} - A program to calculate the factorial of a number.
		\item \texttt{Whitespace.gls} - Random whitespace to test whitespace handling.
	\end{itemize}

	\subsection{Running the Tests}
	To run the tests, we can use the following command, output will be displayed on the console:
	\begin{verbatim}
		$ make test TEST_FILE=test/Sum.gls
    \end{verbatim}
  
    \begin{minted}[fontsize=\footnotesize, linenos, frame=lines]{java}
		token: LET        	lexical unit: LET
		token: sum        	lexical unit: PROGNAME
		token: BE         	lexical unit: BE
		token: IN         	lexical unit: INPUT
		token: (          	lexical unit: LPAREN
		token: a          	lexical unit: VARNAME
		token: )          	lexical unit: RPAREN
		token: :          	lexical unit: COLUMN
		token: IN         	lexical unit: INPUT
		token: (          	lexical unit: LPAREN
		token: b          	lexical unit: VARNAME
		token: )          	lexical unit: RPAREN
		token: :          	lexical unit: COLUMN
		token: c          	lexical unit: VARNAME
		token: =          	lexical unit: ASSIGN
		token: a          	lexical unit: VARNAME
		token: +          	lexical unit: PLUS
		token: b          	lexical unit: VARNAME
		token: :          	lexical unit: COLUMN
		token: END        	lexical unit: END
		token: :          	lexical unit: COLUMN
		token: OUT        	lexical unit: OUTPUT
		token: (          	lexical unit: LPAREN
		token: c          	lexical unit: VARNAME
		token: )          	lexical unit: RPAREN
		token: :          	lexical unit: COLUMN
		token: END        	lexical unit: END

		Variables
		a	4
		b	5
		c	6
	\end{minted}

    \begin{table}[h]
		\centering
		\caption{Test datasheet}
	\end{table}